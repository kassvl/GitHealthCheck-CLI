"""
Data models for health reports and analysis results.

Defines the structure of health reports generated by the analyzer.
"""

from datetime import datetime
from enum import Enum
from typing import List, Dict, Any, Optional
from pathlib import Path

from pydantic import BaseModel, Field


class Priority(str, Enum):
    """Priority levels for recommendations."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"


class SmellType(str, Enum):
    """Types of code smells that can be detected."""
    LONG_FUNCTION = "long_function"
    GOD_CLASS = "god_class"
    DUPLICATE_CODE = "duplicate_code"
    EXCESSIVE_PARAMETERS = "excessive_parameters"
    DEAD_CODE = "dead_code"
    MAGIC_NUMBER = "magic_number"
    COMPLEX_CONDITIONAL = "complex_conditional"
    FEATURE_ENVY = "feature_envy"


class RepositoryInfo(BaseModel):
    """Basic repository information."""
    path: str
    name: str
    analyzed_at: datetime
    total_files: int
    total_lines: int
    languages: Dict[str, int] = Field(default_factory=dict)
    commit_count: int
    contributors: int
    age_days: int


class CodeQualityMetrics(BaseModel):
    """Code quality metrics and scores."""
    overall_score: float = Field(ge=0, le=10)
    cyclomatic_complexity: Dict[str, float] = Field(default_factory=dict)
    function_length_avg: float
    comment_density: float
    naming_consistency: float
    duplication_ratio: float
    complexity_distribution: Dict[str, int] = Field(default_factory=dict)


class ArchitectureMetrics(BaseModel):
    """Architecture and design metrics."""
    score: float = Field(ge=0, le=10)
    dependency_count: int
    circular_dependencies: int
    coupling_score: float
    cohesion_score: float
    srp_violations: int
    module_count: int
    depth_of_inheritance: float


class CodeSmell(BaseModel):
    """Individual code smell instance."""
    type: SmellType
    file_path: str
    line_number: int
    severity: float = Field(ge=0, le=10)
    description: str
    suggestion: Optional[str] = None


class CodeSmellMetrics(BaseModel):
    """Code smell analysis results."""
    total_count: int
    severity_score: float = Field(ge=0, le=10)
    smells_by_type: Dict[SmellType, int] = Field(default_factory=dict)
    hotspot_files: List[str] = Field(default_factory=list)
    smells: List[CodeSmell] = Field(default_factory=list)


class TestMetrics(BaseModel):
    """Test coverage and quality metrics."""
    coverage_score: float = Field(ge=0, le=10)
    test_files_count: int
    test_to_source_ratio: float
    test_success_rate: float
    has_coverage_report: bool
    coverage_percentage: Optional[float] = None
    uncovered_files: List[str] = Field(default_factory=list)


class DocumentationMetrics(BaseModel):
    """Documentation quality metrics."""
    score: float = Field(ge=0, le=10)
    readme_quality: float
    docstring_coverage: float
    api_doc_coverage: float
    has_changelog: bool
    has_contributing_guide: bool
    doc_files_count: int


class SustainabilityMetrics(BaseModel):
    """Repository sustainability and maintenance prediction."""
    score: float = Field(ge=0, le=10)
    maintenance_probability: float = Field(ge=0, le=1)
    activity_trend: str  # "increasing", "stable", "declining"
    bus_factor: int
    recent_activity_score: float
    contributor_diversity: float
    commit_frequency_score: float


class OverallMetrics(BaseModel):
    """Combined metrics from all analysis modules."""
    overall_score: float = Field(ge=0, le=10)
    code_quality: CodeQualityMetrics
    architecture: ArchitectureMetrics
    code_smells: CodeSmellMetrics
    tests: TestMetrics
    documentation: DocumentationMetrics
    sustainability: SustainabilityMetrics


class Recommendation(BaseModel):
    """Actionable recommendation for improving repository health."""
    priority: Priority
    category: str
    description: str
    impact: str
    effort: str  # "low", "medium", "high"
    files_affected: List[str] = Field(default_factory=list)


class HealthReport(BaseModel):
    """Complete health analysis report for a repository."""
    repository: RepositoryInfo
    metrics: OverallMetrics
    recommendations: List[Recommendation] = Field(default_factory=list)
    analysis_duration: float
    version: str = "0.1.0"
    
    def save_json(self, output_path: str) -> None:
        """Save the report as JSON file."""
        import json
        with open(output_path, 'w') as f:
            json.dump(self.model_dump(), f, indent=2, default=str)
    
    def save_yaml(self, output_path: str) -> None:
        """Save the report as YAML file."""
        import yaml
        with open(output_path, 'w') as f:
            yaml.dump(self.model_dump(), f, default_flow_style=False)


class AnalysisConfig(BaseModel):
    """Configuration for analysis behavior."""
    include_patterns: List[str] = Field(default_factory=lambda: ["*.py", "*.js", "*.ts", "*.java", "*.cpp", "*.c", "*.go", "*.rs"])
    exclude_patterns: List[str] = Field(default_factory=lambda: ["*/node_modules/*", "*/.git/*", "*/venv/*", "*/build/*", "*/dist/*"])
    max_file_size_mb: int = 10
    enable_ml_prediction: bool = True
    complexity_threshold: int = 10
    function_length_threshold: int = 50
    parameter_count_threshold: int = 7
    duplication_threshold: float = 0.1
